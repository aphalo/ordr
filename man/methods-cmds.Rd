% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-cmds.r
\name{methods-cmds}
\alias{methods-cmds}
\alias{as_tbl_ord.cmds}
\alias{recover_u.cmds}
\alias{recover_v.cmds}
\alias{recover_inertia.cmds}
\alias{recover_coord.cmds}
\alias{recover_conference.cmds}
\alias{augment_u.cmds}
\alias{augment_v.cmds}
\alias{augment_coord.cmds}
\alias{reconstruct.cmds}
\alias{negate_to.cmds}
\alias{permute_to.cmds}
\alias{rotate_to.cmds}
\title{Functionality for classical multidimensional scaling objects}
\usage{
\method{as_tbl_ord}{cmds}(x)

\method{recover_u}{cmds}(x)

\method{recover_v}{cmds}(x)

\method{recover_inertia}{cmds}(x)

\method{recover_coord}{cmds}(x)

\method{recover_conference}{cmds}(x)

\method{augment_u}{cmds}(x)

\method{augment_v}{cmds}(x)

\method{augment_coord}{cmds}(x)

\method{reconstruct}{cmds}(x)

\method{negate_to}{cmds}(x, y, ..., .matrix)

\method{permute_to}{cmds}(x, y, ..., .matrix)

\method{rotate_to}{cmds}(x, y, ..., .matrix)
}
\arguments{
\item{x}{An ordination object.}

\item{y}{A matrix or an ordination object.}

\item{...}{Additional elements of a custom \code{tbl_ord}.}

\item{.matrix}{A character string matching one of several indicators for one
or both matrices in a matrix decomposition used for ordination. The
standard values are \code{"u"}, \code{"v"}, and \code{"uv"}.}
}
\description{
These methods extract data from, and attribute new data to, objects of class 
\code{"cmds"}. (This is a class introduced in this package to identify 
objects returned by \code{\link[stats]{cmdscale}}, which is masked by a
wrapper that adds the class attribute.)
}
\examples{

# reproduce Exhibit 4.2 in Greenacre (2010)

# format `country_differences` as a matrix
data(country_differences)
x1 <- as.matrix(dplyr::select(country_differences, -Countries))
rownames(x1) <- dplyr::pull(country_differences, Countries)

# multidimensional scaling setup
(m <- cmdscale(x1, k = 2))
(b <- as_tbl_ord(m))
(d <- fortify(b))

# basic multidimensional scaling biplot
gg <- ggbiplot(b, aes(x = PCo1, y = PCo2)) +
  geom_v_text(aes(label = .name))
gg
# default aesthetic assignments
ggbiplot(b) +
  geom_v_text(aes(label = .name))
# numeric aesthetic assignments
ggbiplot(b, aes(x = 2, y = 1)) +
  geom_v_text(aes(label = .name))

# reproduce Exhibit 4.5 in Greenacre (2010)

# format `country_attributes` as a matrix
data(country_attributes)
x2 <- as.matrix(dplyr::select(country_attributes, -Countries))
rownames(x2) <- dplyr::pull(country_differences, Countries)

# regress the attributes on the plotting dimensions and annotate the biplot
fit <- as_tbl_ord(lm(x2 ~ get_u(b)))
gg +
  geom_v_vector(data = fit) +
  geom_v_text_radiate(data = fit, hjust = .3, aes(label = .name))
gg +
  geom_v_vector(data = fit) +
  geom_v_text_radiate(data = fortify(fit, include = "all"), hjust = .3,
                   aes(label = .name))
gg +
  geom_v_vector(data = fit) +
  geom_v_text_radiate(data = fortify(fit, "v"), hjust = .3, aes(label = .name))

dat <- fortify_v(fit)
gg +
  geom_v_vector(data = fit) +
  ggrepel::geom_text_repel(data = dat, aes(label = .name))

# reproduce Exhibit 4.6 in Greenacre (2010)

data(bioenv)

# chi-squared distances
chidist <- function(mat, rowcol = 1) {
  if (rowcol == 1) {
    prof <- mat / apply(mat, 1, sum)
    rootaveprof <- sqrt(apply(mat, 2, sum) / sum(mat))
  }
  if (rowcol == 2) {
    prof <- t(mat) / apply(mat, 2, sum)
    rootaveprof <- sqrt(apply(mat, 1, sum) / sum(mat))
  }
  dist(scale(prof, FALSE, rootaveprof))
}

# `tbl_ord` MDS object
bioenv_chidist <- chidist(bioenv[, 2:6])
bioenv_cmds <- as_tbl_ord(cmdscale(bioenv_chidist))
bioenv_cmds <- mutate_u(bioenv_cmds, .name = bioenv$site)

# sites plot
ggbiplot(bioenv_cmds, aes(label = .name)) +
  geom_u_text()

# sites and species biplot
bioenv_rf <- diag(1 / rowSums(bioenv[, 2:6])) \%*\%
  as.matrix(bioenv[, 2:6]) \%*\%
  diag(sqrt(sum(bioenv[, 2:6]) / colSums(bioenv[, 2:6])))
colnames(bioenv_rf) <- names(bioenv)[2:6]
bioenv_lm <- as_tbl_ord(lm(bioenv_rf ~ get_u(bioenv_cmds)))
ggbiplot(bioenv_cmds, aes(label = .name)) +
  geom_u_text() +
  geom_v_vector(data = bioenv_lm) +
  geom_v_text_radiate(data = bioenv_lm)
}
