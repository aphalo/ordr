% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bibble-alignment.r
\name{bibble-alignment}
\alias{bibble-alignment}
\alias{align_to}
\alias{negate_to}
\alias{permute_to}
\alias{rotate_to}
\alias{negation_to}
\alias{permutation_to}
\alias{rotation_to}
\alias{un_align}
\title{Align one ordination to another of the same cases or variables}
\usage{
align_to(x, y, .matrix)

negate_to(x, y, ...)

permute_to(x, y, ...)

rotate_to(x, y, ...)

negation_to(x, y)

permutation_to(x, y, abs.values = FALSE)

rotation_to(x, y)

un_align(x)
}
\arguments{
\item{x, y}{Matrices or bibbles; \code{x} will be aligned to \code{y}.}

\item{.matrix}{A character string matching one of several indicators for one
or both matrices in a matrix decomposition used for ordination. The
standard values are \code{"u"}, \code{"v"}, and \code{"uv"}.}

\item{...}{Additional parameters passed to methods.}

\item{abs.values}{Whether \code{permute_to} should reorder coordinates
according to dot product magnitudes (angles closest to straight, whether
\eqn{0} or \eqn{\pi}, versus angles closest to \eqn{0}).}
}
\description{
Depending on the method of ordination, its interpretation may not depend on 
the signs, the order, or the orientation of the coordinates. 
\code{negate_to}, \code{permute_to}, and \code{rotate_to} take advantage of 
these symmetries in order to manipulate the coordinates of one ordination so 
that the positions of the cases or variables align, as closely as 
possible, to those of the same cases or variables in another ordination. 
In the case of negation and permutation, this is done by minimizing the 
angles between vectors of scores or loadings in the respective coordinates. 
In the case of rotation, this is done by invoking the singular value 
decomposition method of point cloud registration (Bellekens &al, 2014).
}
\examples{

data(country_differences, country_attributes)

x1 <- as.matrix(dplyr::select(country_differences, -Countries))
rownames(x1) <- dplyr::pull(country_differences, Countries)

(m <- cmdscale(x1, k = 2))
(b1 <- as_bibble(m))
(p <- prcomp(x1))

\dontrun{
(b1_p <- align_to(b1, p$x, "u"))
plot(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(b1) + geom_u_point(),
  ggbiplot(b1_p) + geom_u_point()
), ncol = 2))

(b1_p <- align_to(b1, p$rotation, "v"))
plot(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(b1) + geom_u_point(),
  ggbiplot(b1_p) + geom_u_point()
), ncol = 2))

# Run once methods are implemented for 'prcomp' objects
(b2 <- as_bibble(p))

print(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(b1) + geom_u_point(),
  ggbiplot(b2) + geom_u_point()
), ncol = 2))

(b1_p <- align_to(b1, p$rotation, "v"))

print(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(b1_p) + geom_u_point(),
  ggbiplot(b2) + geom_u_point()
), ncol = 2))
}
}
\references{
Bellekens B., Spruyt V., Berkvens R., & Weyn M. (2014). A survey of rigid 3D
pointcloud registration algorithms. \emph{Fourth International Conference on
Ambient Computing, Applications, Services and Technologies, Proceedings.} p.
8--13.
}
