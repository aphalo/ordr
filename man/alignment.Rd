% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ord-alignment.r
\name{alignment}
\alias{alignment}
\alias{get_alignment}
\alias{revert_alignment}
\alias{negate_ord}
\alias{permute_ord}
\alias{rotate_ord}
\alias{negation_to}
\alias{negate_to}
\alias{negate_to_nonneg_orthant}
\alias{permutation_to}
\alias{permute_to}
\alias{rotation_to}
\alias{rotate_to}
\alias{align_to}
\title{Alignment of ordinations}
\usage{
get_alignment(x)

revert_alignment(x)

negate_ord(x, negation = NULL)

permute_ord(x, permutation = NULL)

rotate_ord(x, rotation = NULL)

negation_to(x, y)

negate_to(x, y, .matrix)

negate_to_nonneg_orthant(x, .matrix)

permutation_to(x, y, abs.values = FALSE)

permute_to(x, y, .matrix)

rotation_to(x, y)

rotate_to(x, y, .matrix)

align_to(x, y, .matrix, method = c("negate", "permute", "rotate"))
}
\arguments{
\item{x, y}{Matrices or \link{tbl_ord}s; \code{x} will be aligned to \code{y}.}

\item{negation, permutation, rotation}{Numeric or character vector of
coordinates to negate or permute, or a matrix that performs an operation by
right-multiplication.}

\item{.matrix}{A character string matching one of several indicators for one
or both matrices in a matrix decomposition used for ordination. The
standard values are \code{"u"}, \code{"v"}, and \code{"uv"}.}

\item{abs.values}{Whether \code{permute_to()} should reorder coordinates according
to dot product magnitudes (angles closest to straight, whether \eqn{0} or
\eqn{\pi}, versus angles closest to \eqn{0}).}

\item{method}{Character, one of \code{"negate"}, \code{"permute"}, or \code{"rotate"},
indicating the alignment method to use.}
}
\description{
Align one ordination to another having the same cases or
variables.
}
\details{
For purposes of comparison and visualization, it can be useful to transform
the (already artificial) coordinates of an ordination, either by fixed
criteria or to better align with another basis (matrix) of coordinates.
\code{negate_ord()}, \code{permute_ord()}, and \code{rotate_ord()} allow the user to
manually transform the coordinates of an ordination by specifying the
coordinates to be negated or permuted, or by providing the rotation matrix.

\code{negate_to()}, \code{permute_to()}, and \code{rotate_to()} manipulate the coordinates
of one ordination so that the positions of the cases or variables align, as
closely as possible, to those of the same cases or variables in another
ordination. In the case of negation and permutation, this is done by
minimizing the angles between vectors of scores or loadings in the respective
coordinates. In the case of rotation, this is done by invoking the singular
value decomposition method of point cloud registration (Bellekens &al, 2014).

The helper functions \code{negation_to()}, \code{permutation_to()}, and \code{rotation_to()}
take only matrix inputs and return matrices that perform the specified
transformations.

\code{get_alignment()} accesses the alignment matrix of an ordination; after
multiple transformations, this matrix will be their composition (product).
\code{revert_alignment()} undoes all alignments. Currently alignments are stored
as an \code{"align"} attribute.
}
\examples{
# Align MDS for distances between American cities with compass orientation
UScitiesD \%>\%
  cmdscale(k = 2) \%>\%
  as_tbl_ord() \%>\%
  augment() \%>\%
  print() -> usa_mds
usa_mds \%>\%
  ggbiplot() +
  geom_v_text(aes(label = .name), size = 3) +
  ggtitle("MDS biplot of distances between American cities")
get_alignment(usa_mds)
# negation
usa_mds \%>\%
  negate_ord(1:2) \%>\%
  print() -> usa_mds_negate
get_alignment(usa_mds_negate)
usa_mds_negate \%>\%
  ggbiplot() +
  geom_v_text(aes(label = .name), size = 3) +
  ggtitle("Negated MDS biplot of distances between American cities")
# rotation
usa_mds \%>\%
  rotate_ord(-diag(2)) \%>\%
  print() -> usa_mds_rotate
get_alignment(usa_mds_rotate)
usa_mds_rotate \%>\%
  ggbiplot() +
  geom_v_text(aes(label = .name), size = 3) +
  ggtitle("Rotated MDS biplot of distances between American cities")
# Align an MDS ordination to a PCA ordination
data(country_differences)
country_differences \%>\%
  cmdscale(k = 2) \%>\%
  as_tbl_ord() \%>\%
  print() -> differences_cmds
country_differences \%>\%
  prcomp() \%>\%
  as_tbl_ord() \%>\%
  print() -> differences_pca
# negate PCA cases to MDS coordinates
differences_cmds \%>\%
  negate_to(differences_pca, "u") \%>\%
  print() -> differences_align_u
plot(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(differences_cmds) + geom_u_point(),
  ggbiplot(differences_pca) + geom_u_point(),
  ggbiplot(differences_align_u) + geom_u_point()
), ncol = 3))
# negate PCA variables to MDS coordinates
differences_cmds \%>\%
  negate_to(differences_pca, "v") \%>\%
  print() -> differences_align_v
plot(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(differences_cmds) + geom_v_vector(),
  ggbiplot(differences_pca) + geom_v_vector(),
  ggbiplot(differences_align_v) + geom_v_vector()
), ncol = 3))
# Compare relative frequences of hair and eye colors among men versus women
HairEyeColor[, , "Male"] \%>\%
  ca::ca() \%>\%
  as_tbl_ord() \%>\%
  print() -> male_haireye_ca
HairEyeColor[, , "Female"] \%>\%
  ca::ca() \%>\%
  as_tbl_ord() \%>\%
  print() -> female_haireye_ca
ca_biplot <- function(ord) {
  ggbiplot(ord, aes(label = .name)) +
    geom_u_point(aes(size = .mass), color = "saddlebrown") +
    geom_v_point(aes(size = .mass), color = "seagreen4") +
    geom_u_text_repel(color = "saddlebrown") +
    geom_v_text_repel(color = "seagreen4") +
    guides(size = "none")
}
plot(gridExtra::arrangeGrob(grobs = list(
  ca_biplot(male_haireye_ca),
  ca_biplot(female_haireye_ca)
), ncol = 2))
# negation, permutation, and rotation
male_haireye_ca \%>\%
  negate_to(female_haireye_ca, "u") \%>\%
  get_alignment()
male_haireye_ca \%>\%
  permute_to(female_haireye_ca, "u") \%>\%
  get_alignment()
male_haireye_ca \%>\%
  rotate_to(female_haireye_ca, "u") \%>\%
  get_alignment()
plot(gridExtra::arrangeGrob(grobs = list(
  ca_biplot(rotate_to(male_haireye_ca, female_haireye_ca, "u")),
  ca_biplot(female_haireye_ca)
), ncol = 2))
}
\references{
Bellekens B, Spruyt V, Berkvens R, & Weyn M (2014) "A survey of rigid 3D
pointcloud registration algorithms". \emph{Fourth International Conference on
Ambient Computing, Applications, Services and Technologies, Proceedings}:
8--13. \url{https://biblio.ugent.be/publication/5713477}
}
