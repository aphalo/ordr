% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ord-alignment.r
\name{alignment}
\alias{alignment}
\alias{negate}
\alias{permute}
\alias{align_to}
\alias{negate_to}
\alias{permute_to}
\alias{rotate_to}
\alias{negation_to}
\alias{permutation_to}
\alias{rotation_to}
\alias{un_align}
\title{Alignment of ordinations}
\usage{
negate(x, coordinates = NULL)

permute(x, coordinates = NULL)

align_to(x, y, .matrix)

negate_to(x, y, ...)

permute_to(x, y, ...)

rotate_to(x, y, ...)

negation_to(x, y)

permutation_to(x, y, abs.values = FALSE)

rotation_to(x, y)

un_align(x)
}
\arguments{
\item{x, y}{Matrices or \code{tbl_ord}s; \code{x} will be aligned to \code{y}.}

\item{coordinates}{Numeric or character vector of coordinates to negate or
permute.}

\item{.matrix}{A character string matching one of several indicators for one
or both matrices in a matrix decomposition used for ordination. The
standard values are \code{"u"}, \code{"v"}, and \code{"uv"}.}

\item{...}{Additional parameters passed to methods.}

\item{abs.values}{Whether \code{permute_to} should reorder coordinates according
to dot product magnitudes (angles closest to straight, whether \eqn{0} or
\eqn{\pi}, versus angles closest to \eqn{0}).}
}
\description{
Align one ordination to another having the same cases or
variables.
}
\details{
Depending on the method of ordination, its interpretation may not depend on
the signs, the order, or the orientation of the coordinates. \code{negate_to()},
\code{permute_to()}, and \code{rotate_to()} take advantage of these symmetries in order
to manipulate the coordinates of one ordination so that the positions of the
cases or variables align, as closely as possible, to those of the same cases
or variables in another ordination. In the case of negation and permutation,
this is done by minimizing the angles between vectors of scores or loadings
in the respective coordinates. In the case of rotation, this is done by
invoking the singular value decomposition method of point cloud registration
(Bellekens &al, 2014).
}
\examples{
# Align an MDS ordination to a PCA ordination
country_differences \%>\%
  cmdscale(k = 2) \%>\%
  as_tbl_ord() \%>\%
  print() -> differences_cmds
country_differences \%>\%
  prcomp() \%>\%
  as_tbl_ord() \%>\%
  print() -> differences_pca
# align PCA cases to MDS coordinates
differences_cmds \%>\%
  align_to(differences_pca$x, "u") \%>\%
  print() -> differences_align_u
plot(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(differences_cmds) + geom_u_point(),
  ggbiplot(differences_pca) + geom_u_point(),
  ggbiplot(differences_align_u) + geom_u_point()
), ncol = 3))
# align PCA variables to MDS coordinates
differences_cmds \%>\%
  align_to(differences_pca$rotation, "v") \%>\%
  print() -> differences_align_v
plot(gridExtra::arrangeGrob(grobs = list(
  ggbiplot(differences_cmds) + geom_v_vector(),
  ggbiplot(differences_pca) + geom_v_vector(),
  ggbiplot(differences_align_v) + geom_v_vector()
), ncol = 3))
}
\references{
Bellekens B, Spruyt V, Berkvens R, & Weyn M (2014) "A survey of rigid 3D
pointcloud registration algorithms." \emph{Fourth International Conference on
Ambient Computing, Applications, Services and Technologies, Proceedings},
8--13. \url{https://biblio.ugent.be/publication/5713477}
}
