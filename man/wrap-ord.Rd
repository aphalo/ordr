% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fun-wrap.r
\name{wrap-ord}
\alias{wrap-ord}
\alias{eigen_ord}
\alias{svd_ord}
\alias{cmdscale_ord}
\alias{logisticSVD_ord}
\alias{logisticPCA_ord}
\alias{convexLogisticPCA_ord}
\title{Wrappers for lossy ordination methods}
\usage{
eigen_ord(x, symmetric = isSymmetric.matrix(x))

svd_ord(x, nu = min(dim(x)), nv = min(dim(x)))

cmdscale_ord(d, k = 2, add = FALSE)

logisticSVD_ord(
  x,
  k = 2,
  quiet = TRUE,
  max_iters = 1000,
  conv_criteria = 1e-05,
  random_start = FALSE,
  ...,
  partial_decomp = TRUE,
  main_effects = TRUE
)

logisticPCA_ord(
  x,
  k = 2,
  m = 4,
  quiet = TRUE,
  partial_decomp = FALSE,
  max_iters = 1000,
  conv_criteria = 1e-05,
  random_start = FALSE,
  ...,
  main_effects = TRUE
)

convexLogisticPCA_ord(
  x,
  k = 2,
  m = 4,
  quiet = TRUE,
  partial_decomp = FALSE,
  max_iters = 1000,
  conv_criteria = 1e-06,
  random_start = FALSE,
  ...,
  main_effects = TRUE,
  ss_factor = 4
)
}
\arguments{
\item{x}{a numeric or complex matrix whose spectral decomposition is to
    be computed.  Logical matrices are coerced to numeric.}

\item{symmetric}{if \code{TRUE}, the matrix is assumed to be symmetric
    (or Hermitian if complex) and only its lower triangle (diagonal
    included) is used.  If \code{symmetric} is not specified,
    \code{\link[base]{isSymmetric}(x)} is used.}

\item{nu}{the number of left  singular vectors to be computed.
    This must between \code{0} and \code{n = nrow(x)}.}

\item{nv}{the number of right singular vectors to be computed.
    This must be between \code{0} and \code{p = ncol(x)}.}

\item{d}{a distance structure such as that returned by \code{dist}
    or a full symmetric matrix containing the dissimilarities.}

\item{k}{the maximum dimension of the space which the data are to be
    represented in; must be in \eqn{\{1, 2, \ldots, n-1\}}{{1, 2, \\dots, n-1}}.}

\item{add}{logical indicating if an additive constant \eqn{c*} should
    be computed, and added to the non-diagonal dissimilarities such that
    the modified dissimilarities are Euclidean.}

\item{quiet}{logical; whether the calculation should give feedback}

\item{max_iters}{number of maximum iterations}

\item{conv_criteria}{convergence criteria. The difference between average deviance
in successive iterations}

\item{random_start}{logical; whether to randomly inititalize the parameters. If \code{FALSE},
function will use an eigen-decomposition as starting value}

\item{...}{Additional parameters passed to original functions.}

\item{partial_decomp}{logical; if \code{TRUE}, the function uses the rARPACK package
to more quickly calculate the eigen-decomposition. This is usually faster than standard
eigen-decomponsition when \code{ncol(x) > 100} and \code{k} is small}

\item{main_effects}{logical; whether to include main effects in the model}

\item{m}{value to approximate the saturated model. If \code{m = 0}, m is solved for}

\item{ss_factor}{step size multiplier. Amount by which to multiply the step size. Quadratic
convergence rate can be proven for \code{ss_factor = 1}, but I have found higher values
sometimes work better. The default is \code{ss_factor = 4}.
If it is not converging, try \code{ss_factor = 1}.}
}
\description{
These \verb{*_ord} functions wrap functions imported from other
packages with modifications for use with 'tbl_ord' methods. Some parameters
are hidden from the user and set to settings required for these methods,
some matrix outputs are given row or column names to be used by them, and
new '*_ord' S3 class attributes are added to enable them.
}
\details{
The following table summarizes the wrapped functions:\tabular{llll}{
   Original function \tab Hide params \tab Add names \tab New class \cr
   \code{\link[base:eigen]{base::eigen()}} \tab Yes \tab Yes \tab Yes \cr
   \code{\link[base:svd]{base::svd()}} \tab Yes \tab Yes \tab Yes \cr
   \code{\link[stats:cmdscale]{stats::cmdscale()}} \tab Yes \tab No \tab Yes \cr
   \code{\link[logisticPCA:logisticSVD]{logisticPCA::logisticSVD()}} \tab No \tab Yes \tab No \cr
   \code{\link[logisticPCA:logisticPCA]{logisticPCA::logisticPCA()}} \tab No \tab Yes \tab No \cr
   \code{\link[logisticPCA:convexLogisticPCA]{logisticPCA::convexLogisticPCA()}} \tab No \tab Yes \tab No \cr
}
}
\examples{
# Graph Laplacian eigenvectors for spectral partitioning
data(karate, package = "igraphdata")
igraph::plot.igraph(
  karate,
  vertex.label.family = "sans",
  vertex.label.color = "black",
  vertex.label.cex = .75
)
# first eigenvector (centrality)
karate_eigen_cent <- igraph::eigen_centrality(karate)
# eigendecomposition
karate \%>\%
  igraph::as_adjacency_matrix(sparse = FALSE) \%>\%
  eigen_ord() \%>\% as_tbl_ord() \%>\%
  mutate_rows(
    faction = igraph::vertex_attr(karate, "Faction"),
    name = igraph::vertex_attr(karate, "name"),
    label = igraph::vertex_attr(karate, "label")
  ) \%>\%
  print() -> karate_eigen
# corroborate eigencentralities
tibble::tibble(
  igraph = karate_eigen_cent$vector,
  eigen = karate_eigen$vectors[, 1] / max(karate_eigen$vectors[, 1])
) \%>\%
  ggplot(aes(x = eigen, y = igraph)) +
  coord_equal() +
  geom_point()
# first and second eigenvectors for centrality and connectivity / partitioning
karate_eigen \%>\%
  confer_inertia(1) \%>\%
  ggbiplot(aes(x = 2, y = 1)) +
  geom_rows_vector(aes(color = as.factor(faction))) +
  geom_rows_text_radiate(aes(label = ifelse(grepl("H|A", label), label, NA))) +
  guides(color = FALSE) +
  labs(x = "algebraic connectivity", y = "eigencentrality") +
  ggtitle(
    "First (centrality) and second (connectivity) eigenvectors",
    "Colors distinguish factions around John A. and Mr. Hi"
  )
# second and third eigenvectors
karate_eigen \%>\%
  confer_inertia(1) \%>\%
  ggbiplot(aes(x = 2, y = 3)) +
  scale_x_continuous(expand = expand_scale(mult = .3)) +
  scale_y_continuous(expand = expand_scale(mult = .2)) +
  geom_rows_vector(aes(color = EV1)) +
  geom_rows_text_radiate(stat = "chull", aes(label = label)) +
  labs(x = "algebraic connectivity", y = "loading onto third eigenvector") +
  ggtitle(
    "Second (horizontal) and third (vertical) eigencentralities",
    "Color increases in value with eigencentrality, labels along convex hull"
  )
}
